= Dealing with Java quircks while switching to FP style

Functional programming promises easy testing reasoning about the execution flow – without surprising exceptions, hard-to-track variables and collections mutations, nor coupling program definition with interpretation.

Thus Java constantly gains more features supporting writing code in functional style, starting with 2014's addition of lambdas and streams of collection elements.
Yet it looks like the language architects are not convinced if fully support that trend by not providing basic combinator methods (`zip`, `zipWith`, `fold`) with existing `Optional<T>` and `Stream<T>` classes, nor classes that can convey information about a failure like `Try<T>` or `Either<E, T>` which limits the possibility of writing more complicated logic without nasty mixture of good old `try {}` s and mutable elements.
Here we'll explore a couple of libraries that make it easier to stay with FP side.

== The basics – data classes
It's not an easy task to operate on data classes without a lot of boilerpate. Getters, builders, equals and hashcode methods can take more space than the data of interests itself. A notable library to cut out the boilerplate is https://mvnrepository.com/artifact/org.immutables/value[Immutables]. A well known, yet controversial library is https://mvnrepository.com/artifact/org.projectlombok/lombok[Lombok]. The former generates the code with concrete implementations form abstract classes, with the latter you'll end up with a different bytecode in your _*.class_ files than in your _*.java_ ones. As I don't mind it as long as IDEs and maven support provides good support, and as there are more chances you already have it in your project, I'll pick Lombok for subsequent examples.

=== How to live without setters

[source,java]
----
import lombok.Builder;
import lombok.Value;

import java.time.ZonedDateTime;
import java.util.Optional;

@Value
@Builder(toBuilder = true)
class Customer {

  @Value
  @Builder(toBuilder = true)
  static class Addrees {

    // Note that if you want to (de)serialize Optionals with Jackson you need to add jackson-datatype-jdk8 dependency and register Jdk8Module module in the Object mapper

    private Optional<String> line1;
    private Optional<String> line2;
    private Optional<String> zipCode;
    private Optional<String> city;
    private Optional<String> country;
  }

  private String name;
  private Addrees address;
  private ZonedDateTime bornOn;
  private Boolean active;
}
----

==== Side note about Optional<T> as a field
When you try to use `Optional<T>` as a field in IntelliJ you'll be greeted with a warning

____
Inspection info: Reports any uses of java.util.Optional<T>, java.util.OptionalDouble, java.util.OptionalInt, java.util.OptionalLong or com.google.common.base.Optional as the type for a field or a parameter. Optional was designed to provide a limited mechanism for library method return types where there needed to be a clear way to represent "no result". Using a field with type java.util.Optional is also problematic if the class needs to be Serializable, which java.util.Optional is not.
____

Don't panic. https://stackoverflow.com/a/26328555[Here's a possible source of the inspection rule] written by https://www.linkedin.com/in/briangoetz/[Brian Goetz]. Usage of `Optional` here is fine for our purpose. Libraries like https://github.com/FasterXML/jackson[Jackson] can deal with (de)serialization. In case of Lombok you need to use https://github.com/FasterXML/jackson-modules-java8[jackson-modules-java8].





Don't revert to isPresent
Zip
Throwing exceptions in the stream
Try/Either vs try{}
Fold vs reduce (sum)
Future with coherent method naming
Beware of mutable collections (immutables, getters-only Lombok)
A look into the future (data classes, pattern matching)

Optional in method parameters (why Lists are good, but Options not?)
Why var, not var

Jeśli decudujesz się na programowanie fuknyjne pozostań przy nim -- unikaj mutowania zmiennych przy map/flatMap -- robisz to po to, żeby móc łatwo prześledzić co się dzieje z kodem i chcesz uniknąć matwienia się, że dane zostaną zmienione gdzieś po drodze

An example with counting the number of elements in a collection (using atomic integer) versus collector

An example with comparing 2 subsequent elements in the collection with zip vs ???

Future having the naming convention coherent with the rest of collections

An example of transferring callback-based approach (cassandra) to Future based approach

Używaj więc niemutowalnych struktur -- te z interfejsami VAVR-owymi mają przewagę nad javowymi nie mając metod set/update, które mogą mogą rzucić wyjątek przy próbie zmiany

Jawnie opakuj rzeczy które mogą się nie powieść w Try/Either, wyjątki typu RuntimeExecption mogą być bolesne do debugowania -- bardzo więc zwracaj uwagę na to czy dany typ jest nullowalny

