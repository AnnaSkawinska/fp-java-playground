= Dealing with Java quircks while switching to FP style

_originally posted on the Idemia Digital Lab Poland https://www.facebook.com/idemiadigitallabpoland/[Facebook page]_

Functional programming promises easy testing and reasoning about the execution flow – without surprising exceptions, hard-to-track variables and collections mutations, nor coupling program definition with interpretation.

Thus Java constantly gains more features supporting writing code in functional style, starting with 2014's addition of lambdas and streams of collection elements.
Yet it looks like the language architects are not convinced if fully support that trend by not providing basic combinator methods (`zip`, `zipWith`, `fold`) with existing `Optional<T>` and `Stream<T>` classes, nor classes that can convey information about a failure like `Try<T>` or `Either<E, T>` which limits the possibility of writing more complicated logic without nasty mixture of good ol' `try {}` s and mutable elements.
Here we'll explore a couple of libraries that make it easier to stay with the FP side.

_All code examples are provided in https://github.com/palkakrzysiek/fp-java-playground[this github repository]._

== The basics – data classes
It's not an easy task to operate on data classes without a lot of boilerpate. Getters, builders, equals and hashcode methods can take more space than the data of interests itself. A notable library to cut out the boilerplate is https://mvnrepository.com/artifact/org.immutables/value[Immutables]. A well known, yet controversial library is https://mvnrepository.com/artifact/org.projectlombok/lombok[Lombok]. The former generates the code with concrete implementations form abstract classes, with the latter you'll end up with a different bytecode in your _*.class_ files than in your _*.java_ ones. As I don't mind it as long as IDEs and maven support provides good support, and as there are more chances you already have it in your project, I'll pick Lombok for subsequent examples.

=== How to live without setters

Here's an example of an immutable class that isn't bloated with unnecessary information (all-args constructor, builder, equals+hashCode, getters).

[source,java]
----
import lombok.Builder;
import lombok.Value;

import java.time.ZonedDateTime;
import java.util.Optional;

@Value
@Builder(toBuilder = true)
class Customer {

  @Value
  @Builder(toBuilder = true)
  static class Addrees {

    // Note that if you want to (de)serialize Optionals with Jackson you need to add jackson-datatype-jdk8 dependency and register Jdk8Module module in the Object mapper

    private Optional<String> line1;
    private Optional<String> line2;
    private Optional<String> zipCode;
    private Optional<String> city;
    private Optional<String> country;
  }

  private String name;
  private Addrees address;
  private ZonedDateTime bornOn;
  private Boolean active;
}
----

Here, the `@Value` annotation creates all the necessary methods (not including setters) to be used in immutable class. To use it in IntelliJ you must turn on annotation processors in settings.

So far so good, the problem appears when one wants to change a single filed in an object. Normally it'd require rewriting all the parameters from the old object to the constructor of the class. It's quite a tedious task and a temptation to add getters by switching `@Value` to `@Data`.

To ease the pain of "mutating" immutable objects one can add a builder with `toBuilder` argument set to `true` (unfortunately it's not a default value). This allows to summon the builder with pre-filled fields from an existing object.

As an simple example let's use the builder to solve a task of deactivating all users in a list.

[source,java]
----
  static List<Customer> deactivateCustomers(List<Customer> customers) {
    return customers
        .stream()
        .map(customer -> customer
            .toBuilder()
            .active(FALSE)
            .build())
        .collect(Collectors.toList());
  }
----

Given a such test data provider

[source,java]
----

  List<Customer> getTestConsumers() {
    return List.of(
        Customer
            .builder()
            .name("John Kovalsky")
            .address(Customer.Addrees
                .builder()
                .line1(of("Warszawska 1"))
                .line2(empty())
                .zipCode(of("00-000"))
                .city(of("Warsaw"))
                .country(of("Poland"))
                .build())
            .active(TRUE)
            .bornOn(ZonedDateTime.of(2014, 3, 18, 12, 0, 0, 0, UTC))
            .build(),
        Customer
            .builder()
            .name("Jan Kowalski")
            .address(Customer.Addrees
                .builder()
                .line1(of("Warszawska 2"))
                .line2(empty())
                .zipCode(of("00-001"))
                .city(of("Warszawa"))
                .country(of("Polska"))
                .build())
            .active(FALSE)
            .bornOn(ZonedDateTime.of(2019, 3, 18, 12, 0, 0, 0, UTC))
            .build()
    );
  }
----


[source,java]
----
  @Test
  void deactivateConsumersTest() {
    var originalList = getTestConsumers();

    var result = deactivateCustomers(originalList);

    result.forEach(customer ->
        assertThat(customer.getActive())
            .describedAs("Customer [" + customer + "] should not be active")
            .isEqualTo(FALSE)
    );

    assertThat(originalList)
        .describedAs("Customer objects in the original list are not modified")
        .containsExactly(getTestConsumers().toArray(new Customer[0]));
  }
----

Now, more complicated example. Given that we must normalize all the country values from local to English names in a collection of `Customer`s.


[source,java]
----

  // the best we can get in a language without type aliases
  @FunctionalInterface
  private interface CustomerMapper extends Function<Customer, Customer> {
  }

  private static CustomerMapper countryRenamer(String oldValue, String newValue) {
    return customer -> {
      var oldAddress = customer.getAddress();
      return customer
          .toBuilder()
          .address(oldAddress
              .toBuilder()
              .country(oldAddress
                  .getCountry()
                  // don't revert to isPresent which makes the code looks not better than if (x != null) {...}
                  // remember that Optional<A> has convenient .map(A -> B) and .flatMap(A -> Optional<B>) methods
                  .map(countryName -> countryName.replace(oldValue, newValue)))
              .build())
          .build();
    };
  }
----

No need of rewriting each field, but still some nested code, is probably the most we can get if we stick to Java. To see how replacing a single element is a nested structure can be cleaned up in other languages check the https://julien-truffaut.github.io/Monocle/optics/lens.html[Lenses concept].

For completeness here's the usage usage (and one country name for simplicity)

[source,java]
----
  static List<Customer> normalizeCountry(List<Customer> customers) {
    var oldVal = "Polska";
    var newVal = "Poland";
    var result = customers
        .stream()
        // as customer is immutable we dont have to worry about changes to the original values in the countryRenamer, whatever its implementation is...
        .map(countryRenamer(oldVal, newVal))
        .collect(Collectors.toList());
    // ... and can compare the original list to the new list
    if (log.isDebugEnabled()) log.debug("Normalized countries from {} resulting in {}", customers, result);
    return result;
  }
----

[source,java]
----
  Set<String> ALlOWED_COUNTRY_NAMES = Set.of("USA", "France", "India", "Poland");

  @Test
  void countryNamesAfterNormalizationContainOnlyAllowedValues() {
    normalizeCountry(getTestConsumers()) .forEach(customer ->
        customer.getAddress().getCountry().ifPresent(countryName ->
            assertThat(countryName)
            .describedAs("The country name of [" + customer + "] after the normalization, if present should be within allowed value set ["+ ALlOWED_COUNTRY_NAMES + "]")
            .isIn(ALlOWED_COUNTRY_NAMES)
            )
        );
  }

----

We can compare the original and new values in the log statement, as the objects from the original list couldn't be modified in the `.map(...)` stream pipeline element.

[source,java]
----
// fillme
----

[source,java]
----
// fillme
----

==== Side note: `Optional<T>` as a field
When you try to use `Optional<T>` as a field in IntelliJ you'll be greeted with a warning

____
Inspection info: Reports any uses of java.util.Optional<T>, java.util.OptionalDouble, java.util.OptionalInt, java.util.OptionalLong or com.google.common.base.Optional as the type for a field or a parameter. Optional was designed to provide a limited mechanism for library method return types where there needed to be a clear way to represent "no result". Using a field with type java.util.Optional is also problematic if the class needs to be Serializable, which java.util.Optional is not.
____

Don't panic. https://stackoverflow.com/a/26328555[Here's a possible source of the inspection rule] written by https://www.linkedin.com/in/briangoetz/[Brian Goetz]. Usage of `Optional` here is fine for our purpose. Libraries like https://github.com/FasterXML/jackson[Jackson] can deal with (de)serialization. With Lombok you need to use https://github.com/FasterXML/jackson-modules-java8[jackson-modules-java8].

==== Side note: developing intuition about the type bounds of generics in methods taking `Function<? super T, ? extends R>` as a parameter

// TODO

== What about the processed `Stream` elements?
A temptation to use mutable state in a `Stream<T>` comes when we need to access a previous element that has already been processed. Say we need to summarize changes in `Customer` objects for auditing purposes. First come up with a  machinery for producing a string with differences between 2 objects.

Here defined is a map of attribute names to their projectors on a customer object

[source,java]
----
  @Value
  private static class ComparableAttribute {
    private String name;
    private Function<Customer, String> getter;
  }

  private static final List<ComparableAttribute> COMPARABLE_ATTRIBUTES = List.of(
      new ComparableAttribute("name", Customer::getName),
      new ComparableAttribute("address", c -> c.getAddress().toString()),
      new ComparableAttribute("born on", c -> c.getBornOn().toString()),
      new ComparableAttribute("is active", c -> c.getActive().toString())
  );
----

Now let's try to define actual builder of a `String` with changes summary

[source,java]
----
  private static Optional<String> valueDiff(String valueName, String v1, String v2) {
    if (v1.equals(v2)) return Optional.empty();
    else return Optional.of(valueName + ": " + v1 + " -> " + v2);
  }

  static String customerDiff(Customer c1, Customer c2) {
    return COMPARABLE_ATTRIBUTES
        .stream()
        .map(attr -> valueDiff(attr.name, attr.getGetter().apply(c1), attr.getter.apply(c2)))
        .filter(Optional::isPresent)
        .map(Optional::get)
        .collect(Collectors.joining(" | "));
  }
----

(test data placed at the end of this section)

[source,java]
----
  @Test
  void customerDiffTest() {
    assertThat(Zipping.customerDiff(c1, c3)).isEqualTo("name: Johny Kovalsky -> Jan Kowalski | born on: 2014-03-18T12:00Z -> 2019-03-18T12:00Z | is active: true -> false");
  }
----

And the use it

[source,java]
----
  static List<String> compareSubsequentChangesWithAtomicRefence(List<Customer> customerStateSnapshots) {
    if (customerStateSnapshots.size() < 2) return Collections.emptyList();
    final var lastValue = new AtomicReference<>(customerStateSnapshots.get(0));
    return customerStateSnapshots
        .stream()
        .skip(1)
        .map(customer -> customerDiff(lastValue.getAndSet(customer), customer))
        .collect(Collectors.toList());
  }
----

The `lastValue` constant indicates a strong desire to use Streams but and problem of enforcing that used variables must be declared as final. `AtomicReference<Customer>` is a quick hack for changing for each loop to the _New Fancy Functional Streams™_. It's a nasty hack, of course. All the promises of simplicity about reasoning about code is thrown away when one needs to keep track of all the places where a variable can be mutated. One can argue that it's not a big deal when the mutable state isn't leaked outside such a method, and it's valid claim. But in this case it'd be easier to just use a variable and old loops.

[source,java]
----
  private Addrees address = Addrees
                .builder()
                .line1(of("Warszawska 1"))
                .line2(empty())
                .zipCode(of("00-000"))
                .city(of("Warsaw"))
                .country(of("Poland"))
                .build();

  private Customer c1 = Customer
            .builder()
            .name("Johny Kovalsky")
            .address(address)
            .active(TRUE)
            .bornOn(ZonedDateTime.of(2014, 3, 18, 12, 0, 0, 0, UTC))
            .build();

  private Customer c2 = Customer
      .builder()
      .name("John Kovalsky")
      .address(address)
      .active(TRUE)
      .bornOn(ZonedDateTime.of(2014, 3, 18, 12, 0, 0, 0, UTC))
      .build();

  private Customer c3 = Customer
            .builder()
            .name("Jan Kowalski")
            .address(address)
            .active(FALSE)
            .bornOn(ZonedDateTime.of(2019, 3, 18, 12, 0, 0, 0, UTC))
            .build();

----


[source,java]
----
// TODO fillme
----



Don't revert to isPresent
Zip
Throwing exceptions in the stream
Try/Either vs try{}
Fold vs reduce (sum)
Future with coherent method naming
Beware of mutable collections (immutables, getters-only Lombok)
A look into the future (data classes, pattern matching)

Optional in method parameters (why Lists are good, but Options not?)
Why var, not var

Jeśli decudujesz się na programowanie fuknyjne pozostań przy nim -- unikaj mutowania zmiennych przy map/flatMap -- robisz to po to, żeby móc łatwo prześledzić co się dzieje z kodem i chcesz uniknąć matwienia się, że dane zostaną zmienione gdzieś po drodze

An example with counting the number of elements in a collection (using atomic integer) versus collector

An example with comparing 2 subsequent elements in the collection with zip vs ???

Future having the naming convention coherent with the rest of collections

An example of transferring callback-based approach (cassandra) to Future based approach

Używaj więc niemutowalnych struktur -- te z interfejsami VAVR-owymi mają przewagę nad javowymi nie mając metod set/update, które mogą mogą rzucić wyjątek przy próbie zmiany

Jawnie opakuj rzeczy które mogą się nie powieść w Try/Either, wyjątki typu RuntimeExecption mogą być bolesne do debugowania -- bardzo więc zwracaj uwagę na to czy dany typ jest nullowalny

